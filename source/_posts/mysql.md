---
title: mysql
date: 2024-04-06 23:19:30
tags: ["MySql","SQL"]
categories: ["SQL","MySql"]
---
# mysqL

## **索引**

###     1、**种类**：

#### 1、逻辑区分：

- **主键索引**: 特殊的唯一索引，不允许值重复或者值为空
- **唯一索引：**与普通索引类似，不同的是创建唯一索引的目的不是为了提高访问速度，而是为了避免数据出现重复
- **普通索引：**没有任何限制，唯一任务就是加快系统对数据的访问速度，允许值重复和空值
- **空间索引：**（只能在MyISAM引擎中使用）必须将列设置成 NOT NULL
- **全文索引：(只在MYISAM引擎中有)**主要是用来查找文本中的关键字，只能在CHAR、VARCHAR 或TEXT类型的列上创建，允许列          中插入重复值和空值。  <span style="color:red">*注意**：**对应大容量的数据表，生成全文索引非常消耗时间和硬盘空间*</span>

#### 2、存储方式区分：

- **B-Tree 索引**：B-Tree（平衡树）索引是 MySQL 最常见的索引类型之一。它以平衡树的结构存储数据，使得查找、插入和删除操作都能在 O(log n) 的时间复杂度内完成。适用于各种数据类型，包括数字、字符串等。
- **B+Tree 索引**：B+Tree 索引是 B-Tree 索引的一种变体，常用于数据库系统中。与普通的 B-Tree 索引相比，B+Tree 索引在内部节点只存储键值信息，而实际数据都存储在叶子节点中，提高了查询性能。适用于范围查询等操作。
- **哈希索引**：哈希索引将索引列的哈希值与数据的存储位置关联起来。适用于等值查询，但不适用于范围查询或排序操作。在某些情况下可以提供快速的查询性能，但有一些限制，如不支持部分索引和排序操作。

### 2、索引的目的和优势

1. **快速数据检索**：索引加速了数据的查找操作，使得数据库能够更快地定位所需的数据行，减少查询时间复杂度。

2. **加速排序和分组操作**：索引提高了排序和分组操作的效率，使数据库能更快地执行这些操作以满足查询需求。

3. **支持唯一约束**：创建唯一索引可以确保特定列的值是唯一的，避免了数据冗余和重复。

4. **优化连接操作**：索引显著提高了连接操作的性能，降低了连接操作的时间复杂度。

5. **提高数据完整性**：索引可以用来强制实施数据完整性，例如通过外键索引确保相关数据的一致性和有效性。

6. **减少磁盘 I/O**：索引减少了从磁盘读取的数据量，从而降低了磁盘 I/O 操作的开销。

虽然索引在提升查询性能方面具有明显优势，但也需要权衡。索引的创建会占用存储空间，并且在数据插入、更新和删除操作时可能导致性能下降。

### **3、<span style="color:green">一条sql的执行过程：</span>**

<a style="color:green">**MySql驱动:**</a>

![db-mysql-sql-1](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318200.png)

这样，在系统和mysql进行交互之前，Mysql驱动会帮我们建立好链接，然后我们只需要发送sql语句就可以进行crud，一次sql请求就会建立一个链接，多个请求就会建立多个链接，so问题来了，我们的系统肯定是多个人在同时使用，我们的web系统一般都是部署在tomcat容器中，tomcat容器是可以并发处理多个请求的这就导致多个请求都会建立链接，然后使用完再去关闭，这样就会出现一个问题，如下图

![](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318201.png)

Java系统通过mysql驱动和mysql数据库链接的时候是基于TCP/IP协议，所以每个请求都是新建和销毁链接，那这样必然造成不必要的浪费和性能的下降，因此使用数据库连接池就能很好的解决这个问题。

**数据库连接池：**维护一定的连接数，方便系统获取链接，使用就去池子中获取，用完了再放回就可以了，我们不需要关系链接的创建和销毁，也不需要关心线程池是怎么去维护这些链接的。

​	![db-mysql-sql-3](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318203.png)

常见的数据库连接池：Durid、C3p0、DBCP...

#### 数据库连接池

到此我们应该知道Java系统在访问mysql时，建立的链接并不是每次请求都会去创建，而是从数据库连接池中去获取.这样就解决了因为反复创建和销毁而带来的性能损耗。  **but,业务系统是并发的,而Mysql接受请求的线程只有一个？**

**NO、NO、NO** mysql架构体系中也提供了一个这样的池子，<span style="color:red">数据库连池</span>.  双方都是通过数据库连接池管理各个链接，这样一方面线程之间不需要相互争抢连接，更重要的是不需要反复的创建和销毁链接。

​				![db-mysql-sql-4](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318204.png)

至此系统和mysql之间的链接问题都已经大致说清楚，但是 mysql数据库中这些链接是怎么处理的，又是谁来处理呢？

#### 网络连接必须由线程来处理

也就是说对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的。![db-mysql-sql-5](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318205.png)

#### 查询解析器

假设有一个sql

```sql
SELECT stuName,age,sex FROM students WHERE id=1
```

人能读懂，机器可不知道啊，这个时候解析器就上场了，他将sql接口传递过来的sql语句进行解析，翻译成mysql自己能认识的语言。![db-mysql-sql-6](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318206.png)

现在sql已经被解析成他能看懂的样子了，下一步就开始执行？ nonono, 要是这样你就把mysql看扁了，他会帮我们选择最优的查询路径。  <span style="color:red"> **什么叫最优查询路径?** </span><span style="color:green"> **就是Mysql会按照自己认为效率最高的方式去执行**</span>

具体怎么玩的，请接着读

#### MySql查询优化器

内部怎么玩的，咱们暂时不做探究:joy::joy::joy:，我们只需要知道MySql会帮我们去使用他自己认为最好的方式去优化这条sql，并生成一条条执行计划，就比如你创建的多个索引，Mysql会一句成本最小原则选择使用对应的索引。这里成本主要包括两个方面：

**1、IO成本 :** 从磁盘把数据加载到内存中的成本，默认情况下，读取数据页的IO成本是1，Mysql是以页的形式读取数据的，就是当用到某个数据时,并不会读取这个数据，而是把这个数据相邻的数据也一块读取到内存中。——————这玩意就是有名的局部性原理(我咋没听说过:joy:)所以mysql每次会读取一整页，一页的成本就是1,。因此IO的成本主要和页的大小有关。

**2、CPU成本:**将数据读入到内存中后，还要检测数据是否满足条件和排序。这玩意就是要cpu来处理了，显然与他的行数有关系。默认情况下，检测记录的成本是0.2。

综上，mysql优化器会计算「IO 成本 + CPU」 成本最小的那个索引来执行

![db-mysql-sql-7](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318207.png)

至此，就会调用存储引擎接口，开始去执行被mysql解析和优化后的sql语句啦。:smile::joy::joy::joy:

#### <span style="color:green">存储引擎（非常重要的一个组件）</span>

查询优化器会调用存储引擎的接口，去执行sql,也就是**:dog:真正执行sql的动作是在存储引擎中完成的:dog:**，数据是被放在了内存或者磁盘中 ，**下面详细介绍了**

#### 执行器

这玩意吧:joy:也是一个非常重要的组件，因为前面哪些组件的操作最终必须通过执行器去调用存储引擎接口才能被执行。执行器最终根据一些列的执行计划去调用存储引擎的接口去完成sql的执行。![db-mysql-sql-8](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318208.png)

#### 初识存储引擎

我们以一个更新语句来说明

```sql
UPDATE students SET stuName = '小强' WHERE id = 1
```

当系统中发送这个sql时，mysql就会按照上面写的流程，最终通过执行器调用存储引擎去执行，流程图就是头上这个:point_up::point_up::point_up:。

在执行这个sql的时候，对应的数据 要么在内存中，要么在磁盘中，如果直接在磁盘中操作。那不就芭比Q了。:sweat_smile::sweat_smile::sweat_smile:速度和80岁老太太一样慢，因此每次执行sql的时候，都会将数据加载到内存中。**这一部分内存就是InnoDB中一个非常重要的组件:缓冲池 Buffer Pool**

#### Buffer Pool(缓冲池)

这玩意是InnoDB存储引擎中非常重要的内存结构，其实就是和redis一样的作用，起到一个缓存的作用，因为mysql数据最终都是存储在磁盘中的，要是没这个缓冲池，那只能去内存中查找，那么IO成本必然很高，那就芭比Q了，**但是有了这个缓冲池，我们在第一次查询后，就将数据存到这个缓冲池中，这样后面再有请求的时候就会先从缓冲池中去查询，没有再去磁盘中查找**

![db-mysql-sql-9](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318209.png)

解读一下上图::point_up:

- innodb存储引擎会在缓存池中查询id = 1的这条数据是否存在
- 发现缓存池中没有，那就就去磁盘中加载，并将数据放在缓存池中
- 该条记录会被加上一个单独锁:lock:(不能你在修改的时候别人也在修改吧，这个机制暂且不说，以后再说)

#### undo日志文件:记录数据被修改前的样子

顾名思义，undo就是没有做， undo log就是没有发生事情的一些日志

我刚刚已经说了在准备更新一条语句的时候，该条语句已经被加载到Buffer Pool中了，实际上这里还有这样的操作，就是在将该语句加载到Buffer Pool中的时候，同时会往undo日志文件中插入一条日志，也就是将id=1的这条记录原来的值记录下来。

**为啥这样做？**

​	innodb 存储引擎最大的特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有操作都必须回滚到执行前的样子。

![db-mysql-sql-10](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318210.png)

<span style="color:green">**注意：到这一步，我们执行的sql语句的数据已经被加载到buffer pool中，然后开始更新这条语句。更新实际上是在Buffer Pool中执行的。因此问题来了，buffer pool中的数据和数据库中的不一样啊，这不就是脏数据了？没错就是脏数据，这种情况mysql是如何处理的呢？**</span>

#### redo日志文件：记录数据被修改后的样子

除了从磁盘中加载文件和将操作前的记录保存到undo日志文件中，其他操作是在内存中完成的，内存中的数据有一个最大缺点就是，<span style='color:red'>**断电丢失**</span>，这个时候redo日志文件就要大显神通了。

**注意：redo日志是innodb存储引擎特有的，因此是存储引擎级别的，不是MySql级别的  --bin.log是mysql级别的**

redo记录的是数据修改后的值，不管事务是否提交都会被记录下来，例如：要做的是update students set stuName='小强' where id=1; 那么这条操作就会被记录到 <span style='color:red'>**redo log buffer** 中，**啥？怎么又出来一个 redo log buffer ,很简单，MySQL 为了提高效率，所以将这些操作都先放在内存中去完成，然后会在某个时机将其持久化到磁盘中。**</span>

![db-mysql-sql-11](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318211.png)

截止到目前，我们应该熟悉了MySql的执行用存储引擎是怎么将一条sql加载到缓存池和记录哪些日志的。流程如下: :point_down:

1. **准备更新一条sql语句**
2. **mysql(innodb)先去缓冲池(Buffer Pool)中查找这条数据，没找到就去磁盘中查找，如果查找到了就会将这条数据加载到缓冲池中。**
3. **在加载到Buffer Pool的同时，会将这条数据的原始记录保存到undo日志文件中。**
4. **innodb会在Buffer Pool中执行更新操作。**
5. **MySql提交事务的时候，会将redo log buffer中的数据写入到redo日志文件中，刷磁盘可以通过innodb_flush_log_at_trx_commit参数来设置:**
    - **0-不刷入磁盘**
    - **1-立即刷入磁盘**
    - **2-先刷到os cache中**
6. **mysql重启的时候会将redo日志恢复到换冲池中。**

到此执行器调用存储引擎的接口去执行提供的sql的时候 innodb做的事情基本差不多了，但是还没结束，下面介绍一下mysql级别的日志文件 **bin log** :point_down:

#### bin log日志文件:记录整个操作过程

redo log记录偏向于物理性质的，比如:对什么数据，做了什么修改，

bin log记录偏向于逻辑性质的，比如：对students表id为1的记录做了更新操作。

两者区别如下：:point_down:

|   性质   |                         redo Log                         |                           bin Log                            |
| :------: | :------------------------------------------------------: | :----------------------------------------------------------: |
| 文件大小 |                         大小固定                         | 可以通过max_bin log_siz设置每个bin log文件的大小，但是不建议 |
| 实现方式 |                     innodb引擎实现的                     |                       mysql级别实现的                        |
| 记录方式 | 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志 | 采用追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上 |
| 使用场景 |      适用于崩溃恢复(crash-safe)类似于Redis的持久化       |                   适用于主从复制和数据恢复                   |

**bin log文件是如何刷入磁盘的?**

bin log刷盘是有相关的策略的，策略可以通过sync_bin log来修改，默认为0，表示先写入os cache，也就是在提交事务的时候，数据不会直接到磁盘中,如果这样宕机bin log数据仍然会丢失,因此建议将sync_bin log 设置成1，表示直接将数据写入到磁盘中。

刷入bin log有以下几种模式：:point_down:

**statment**

基于sql语句复制，每一条会修改的数据的sql语句会记录到bin log中

【优点】: 不需要记录每一行的变化，减少了bin log日志量，减少了IO,提升了性能

【缺点】：在某些情况下会导致主从不一致，比如执行sysdate()、sleep()等

**row**

基于行的复制，不记录每条sql语句的上下文信息,仅需记录那条数据被修改了

【优点】：不会出现某些特定情况下的存储过程、function、trigger的调用和触发无法被正确复制的问题

【缺点】：会产生大量的日志，特别是在alert table的时候让日志暴涨

**mixed**

基于statment和row两种模式的混合模式，一般的复制使用statment模式保存bin log，对于statment模式无法复制的操作使用row模式保存bin log

<span style='color:green'>**既然bin log也是日志文件，那它是在什么记录数据的呢？？？**
🤔</span>

答：其实mysql在提交事务的时候，不仅仅将redo log buffer中的数据写入到redo log文件中，同时也会将本次修改的数据记录到bin log文件中,同时会将本次修改的bin log文件名和修改的内容在bin log 中的位置记录到redo log中，最后还会在redo log最后写入commit标记，这样就表明本次事务被成功的提交了。

<img src="https://raw.githubusercontent.com/zpnvliba/images/main/202404062318212.png" alt="db-mysql-sql-13"  />

**问题：如果数据被写入到bin log文件的时候，刚写完，数据库宕机了，数据会丢失吗?**

**答：**首先可以确定的是，只要redo log最后没有commit标记，说明本次事务一定是失败的，但是数据没有丢失，因为已经被记录到redo log的磁盘中了，在mysql重启的时候，就会将redo log中的数据加载到Buffer Pool中。

<span style='color:green'>**其实MySql会有一个后台线程，他会在某个时机将我们的Buffer Pool中的脏数据刷到MySql数据库中，这样就将内存和数据库中的数据保持统一了。**</span>

![db-mysql-sql-14](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318213.png)

### **总结**

- Buffer Pool是MySQL的一个非常重要的组件，因为针对数据库的CRUD都是在Buffer Pool中完成的。
- undo log记录的是数据操作前的样子
- redo lod 记录的是数据被操作后的样子
- bin log记录的是整个操作记录(这对于主从复制具有非常重要的意义)

<span style='color:green'>**从准备更新一条数据到事务的提交的流程描述:**</span>

1. 执行器根据MySQL的执行计划来查询数据，先从缓存池中查询数据，如果没有就去数据库中查询，如果查询到了就将其放到缓存池中。

2. 在数据被缓存到缓存池的同时，也会写入undo log日志文件

3. 更新的动作是在Buffer Pool中完成的，同时会将更新后的数据添加到redo log buffer中

4. 完成以后既可以提交事务，在提交事务的同时会做一下三件事：

    - 将redo log buffer中的数据刷入到redo log文件中
    - 将本次操作记录写入到bin log文件中
    - 将bin log文件名字和更新内容在bin log中的位置记录到redo log中,同时在redo log最后添加commit 标记

   至此表示整个更新事务已经完成



### **3、MySQL-索引(B+树)**

#### 1、**数据结构**

B Tree，也就是平衡树，平衡树是一颗查找树，并且所有叶子结点位于同一层

B+ Tree 是基于B Tree和叶子结点顺序访问指针进行实现，它具有B Tree的平衡性，并且通过顺序指针来提高区间查询性能。

在B+Tree中，一个节点中的key从左到右非递减排列，如果某个指针的左右相邻keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1

![061c88c1-572f-424f-b580-9cbce903a3fe](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318214.png)

#### 2、操作

进行查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归的在指针所指向的结点进行查找，直到查找到叶子结点，然后在叶子节点上进行二分查找，找到key所对应的data。插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作后，需要对树进行分裂、合并、旋转等操作来维护平衡性。

#### 3、与红黑树的比较

红黑树等平衡树也可以实现索引，但是文件系统及数据库系统普遍采用B+Tree作为索引结构，主要有两个原因：:point_down:

1. **更少的查找次数**

    - 平衡树查找操作的时间复杂度等于树高h，O(h) = O(log_{d}N)
    - 红黑树的出度为2，B+Tree的出度一般非常大，所以树高就低了。检索次数就少了

2. 利用计算机预读性质

    - 为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。

      操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。

------



#### MySql索引：

​	索引是在存储引擎实现的，不是在服务器层实现的，所以不同的存储引擎具有不用的索引类型和实现

1. **B+Tree索引**

   ​	是大多数MySql存储引擎的默认索引类型。

   ​	因为不需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。还可以快速排序和分组。

   ​	可以指定多个列作为索引列，多个索引列共同组成键、

   ​	适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列进行顺序查找，则无法使用索引。

   InnoDB的B+Tree索引分为主索引和辅助索引。

   主索引的叶子结点data域记录完整的数据记录，这种索引方式被称为聚簇索引，因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

![061c88c1-572f-424f-b580-9cbce903a3fe](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318214.png)

辅助索引的叶子节点的data域记录主键的值，因此在使用辅助索引进行查找的时候，需要先查找主键索引，然后再到主索引中进行查找。



![7ab8ca28-2a41-4adf-9502-cc0a21e63b51](https://raw.githubusercontent.com/zpnvliba/images/main/202404062318215.jpg)

**2、哈希索引**

哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

​	**3. 全文索引**

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

4. **空间数据索引**

MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。

### 索引优化

**1、独立的列：**

​	在查询时，索引不能是表达式的一部分，也不能是函数的参数，否则索引失效。

**2、多列索引**

​	在需要使用多个列进行条件进行查询的时候，使用多列索引比使用多个单列索引性能更好。

**3、索引列的顺序**

​	让选择性最强的索引列放在前面，索引的选择性是指，不重复的索引值和记录总数的比值，最大值为1，此时每个记录都有唯一索引与其对应，选择性越高，查询效率也越高。

**4、前缀索引**

​	对于BLOB、TEXT、VARCHAR类型的列，必须使用前缀索引。

**5、覆盖索引**

​	索引包含所有需要查询的字段的值。

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量
- 一些存储引擎在内存中只缓存索引，而数据以来操作系统来缓存。因此只访问索引可以不使用系统调度，
- 对弈InnoDB引擎，若辅助索引能覆盖查询，则无需访问主索引。

### **索引的优点**

- **大大减少了服务器需要扫描的数据行**
- **帮助服务器避免进行排序和分组，也就不需要创建临时表。(B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表)**
- **将随机I/O变为顺序I/O(B+Tree索引是有序的，也就将相邻的数据都存储在一起)**

### **索引的使用场景**

1. 对于非常小的表、大部分情况下简单的全表扫描比建立索引更加高效
2. 对于中大型的表，索引就非常有效
3. 对于特别大的表，建立和维护索引的代价将随之增长，这中情况下，需要分库分表或者分区。